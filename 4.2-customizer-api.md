#Theme Options – The Customizer API

The Customizer is a framework for live-previewing any change to WordPress. It provides a simple and consistent interface for users to customize various aspects of their theme and their site, from colors and layouts to widgets, menus, and more. Themes and plugins alike can add custom options to the Customizer. The Customizer is the canonical way to add options to your theme.

Customizer options can be granted to users with different capabilities on a granular basis, so while most options are visible only to administrators by default, other users may access certain options if you want them to be able to. Different parts of the Customizer can also be contextual to whether they’re relevant to the front-end context that the user is previewing. For example, the core widgets functionality only shows widget areas that are displayed on the current page; other widget areas are shown when the user navigates to a page that includes them within the Customizer preview window.

This page contains an overview of the Customizer API, including code examples and discussion of best practices. For more details, it is strongly recommended that developers study the core Customizer code (all core files containing “customize”). This is considered the canonical, official documentation for the Customizer API outside of the inline documentation within the core code.

![customizer-4.2](https://developer.wordpress.org/files/2014/10/customizer-4.2-1024x516.png)

##Customizer Objects

The Customizer API is object-oriented. There are four main types of Customizer objects: Panels, Sections, Settings, and Controls. Settings associate UI elements (controls) with settings that are saved in the database. Sections are UI containers for controls, to improve their organization. Panels are containers for sections, allowing multiple sections to be grouped together.

Each Customizer object is represented by a PHP class, and all of the objects are managed by the Customize Manager object, [WP_Customize_Manager](https://developer.wordpress.org/reference/classes/wp_customize_manager/).

![customizer-object-types](https://developer.wordpress.org/files/2014/10/customizer-object-types.png)

To add, remove, or modify any Customizer object, and to access the Customizer Manager, use the [customize_register](https://developer.wordpress.org/reference/hooks/customize_register/) hook:

```php
<?php
function themeslug_customize_register( $wp_customize ) {
    // Do stuff with $wp_customize, the WP_Customize_Manager object.
}
add_action( 'customize_register', 'themeslug_customizer_setup' );
?>
```

The Customizer Manager provides `add_`, `get_`, and `remove_` methods for each Customizer object type; each works with an id. The `get_` methods allow for direct modification of parameters specified when adding a control.

```php
<?php
add_action('customize_register','my_customize_register');
function my_customize_register( $wp_customize ) {
    $wp_customize->add_panel();
    $wp_customize->get_panel();
    $wp_customize->remove_panel();

    $wp_customize->add_section();
    $wp_customize->get_section();
    $wp_customize->remove_section();

    $wp_customize->add_setting();
    $wp_customize->get_setting();
    $wp_customize->remove_setting();

    $wp_customize->add_control();
    $wp_customize->get_control();
    $wp_customize->remove_control();
}
?>
```

##Settings

Settings handle live-previewing, saving, and sanitization of your Customizer objects. Each setting is managed by a control object. There are several parameters available when adding a new setting:

```php
<?php
$wp_customize->add_setting( 'setting_id', array(
    'type' => 'theme_mod', // or 'option'
    'capability' => 'edit_theme_options',
    'theme_supports' => '', // Rarely needed.
    'default' => '',
    'transport' => 'refresh', // or postMessage
    'sanitize_callback' => '',
    'sanitize_js_callback' => '', // Basically to_json.
) );
?>
```

There are two primary types of settings: options and theme modifications. Options are stored directly in the `wp_options` table of the WordPress database and apply to the site regardless of the active theme. Themes should rarely if ever add settings of the option type. Theme mods, on the other hand, are specific to a particular theme. Most theme options should be `theme_mods`. For example, a custom CSS plugin could register a custom theme css setting as a `theme_mod`, allowing each theme to have a unique set of CSS rules without losing the CSS when switching themes then switching back.

![customize-theme-mods-options](https://developer.wordpress.org/files/2014/10/customize-theme-mods-options-1024x574.png)

It is usually most important to set the default value of the setting as well as its sanitization callback, which will ensure that no unsafe data is stored in the database. Typical theme usage:

```php
<?php
$wp_customize->add_setting( 'accent_color', array(
    'default' => '#f72525',
    'sanitize_callback' => 'sanitize_hex_color',
) );
?>
```

Typical plugin usage:

```php
<?php
$wp_customize->add_setting( 'myplugin_options[color]', array(
    'type' => 'option',
    'capability' => 'manage_options',
    'default' => '#ff2525',
    'sanitize_callback' => 'sanitize_hex_color',
) );
?>
```

Note that the Customizer can handle options stored as keyed arrays for settings using the option type. This allows multiple settings to be stored in a single option that isn’t a theme mod. To retrieve and use the values of your Customizer options, use [get_theme_mod()](https://developer.wordpress.org/reference/functions/get_theme_mod/) and [get_option()](https://developer.wordpress.org/reference/functions/get_option/) with the setting id:

```php
<?php
function my_custom_css_output() {
    echo '<style type="text/css" id="custom-theme-css">' .
    get_theme_mod( 'custom_theme_css', '' ) . '</style>';
    echo '<style type="text/css" id="custom-plugin-css">' .
    get_option( 'custom_plugin_css', '' ) . '</style>';
}
add_action( 'wp_head', 'cxnh_custom_css_output');
?>
```

Note that the second argument for [get_theme_mod()](https://developer.wordpress.org/reference/functions/get_theme_mod/) and `get_option()` is the default value, which should match the default you set when adding the setting.

##Controls

Controls are the primary Customizer object for creating UI.  Specifically, every control must be associated with a setting, and that setting will save user-entered data from the control to the database (in addition to displaying it in the live-preview and sanitizing it). Controls can be added by the Customizer Manager and provide a robust set of UI options with minimal effort:

```php
<?php
$wp_customize->add_control( 'setting_id', array(
    'type' => 'date',
    'priority' => 10, // Within the section.
    'section' => 'colors', // Required, core or custom.
    'label' => __( 'Date' ),
    'description' => __( 'This is a date control with a red border.' ),
    'input_attrs' => array(
        'class' => 'my-custom-class-for-js',
        'style' => 'border: 1px solid #900',
        'placeholder' => __( 'mm/dd/yyyy' ),
    ),
    'active_callback' => 'is_front_page',
) );
?>
```

The most important parameter when adding a control is its type — this determines what type of UI the Customizer will display. Core provides several built-in control types:

- checkbox
- textarea
- radio (pass a keyed array of values => labels to the choices argument)
- select (pass a keyed array of values => labels to the choices argument)
- dropdown-pages

For any input type supported by the html `<input>` element, simply pass the type attribute value to the type parameter when adding the control. This allows support for control types such as text, hidden, number, range, url, tel, email, search, time, date, datetime, and week, pending browser support.

Controls must be added to a section before they will be displayed (and sections must contain controls to be displayed). This is done by specifying the section parameter when adding the control. Here is an example for adding a basic textarea control:

```php
<?php
$wp_customize->add_control( 'custom_theme_css', array(
    'label' => __( 'Custom Theme CSS' ),
    'type' => 'textarea',
    'section' => 'custom_css',
) );
?>
```

And here’s an example of a basic range (slider) control. Note that most browsers will not display the numeric value of this control because the range input type is designed for settings where the exact value is unimportant. If the numeric value is important, consider using the number type. The `input_attrs` parameter will map a keyed array of attributes => values to attributes on the input element, and can be used for purposes ranging from placeholder text to data- JavaScript-referenced data in custom scripts. For number and range controls, it allows us to set the minimum, maximum, and step values.

```php
<?php
$wp_customize->add_control( 'setting_id', array(
    'type' => 'range',
    'section' => 'title_tagline',
    'label' => __( 'Range' ),
    'description' => __( 'This is the range control description.' ),
    'input_attrs' => array(
        'min' => 0,
        'max' => 10,
        'step' => 2,
    ),
) );
?>
```

###Core Custom Controls

If none of the basic control types suit your needs, you can easily create and add custom controls. Custom controls are explained more fully later in this post, but they are essentially subclasses of the base [WP_Customize_Control](https://developer.wordpress.org/reference/classes/wp_customize_control/) object that allow any arbitrary html markup and functionality that you might need. Core features several built-in custom controls that allow developers to implement rich JavaScript-driven features with ease. A color picker control can be added as follows:

```php
<?php
$wp_customize->add_control( new WP_Customize_Color_Control( $wp_customize, 'color_control', array(
    'label' => __( 'Accent Color', 'theme_textdomain' ),
    'section' => 'media',
) ) );
?>
```

WordPress 4.1 and 4.2 also added support for any type of multimedia content, with the Media control. The media control implements the navite WordPress media manager, allowing users to select files from their library or upload new ones. By specifying the `mime_type` parameter when adding the control, you can instruct the media library show to a specific type such as images or audio:

```php
<?php
$wp_customize->add_control( new WP_Customize_Media_Control( $wp_customize, 'image_control', array(
    'label' => __( 'Featured Home Page Image', 'theme_textdomain' ),
    'section' => 'media',
    'mime_type' => 'image',
) ) );

$wp_customize->add_control( new WP_Customize_Media_Control( $wp_customize, 'audio_control', array(
    'label' => _( 'Featured Home Page Recording', 'theme_textdomain' ),
    'section' => 'media',
    'mime_type' => 'audio',
) ) );
?>
```

##Sections

Sections are UI containers for Customizer controls. While you can add custom controls to the core sections, if you have more than a few options you may want to add one or more custom sections. Use the add_section method of the WP_Customize_Manager object to add a new section:

```php
<?php
$wp_customize->add_section( 'custom_css', array(
    'title' => __( 'Custom CSS' ),
    'description' => __( 'Add custom CSS here' ),
    'panel' => '', // Not typically needed.
    'priority' => 160,
    'capability' => 'edit_theme_options',
    'theme_supports' => '', // Rarely needed.
) );
?>
```

You only need to include fields that you want to override the default values of. For example, the default priority (order of appearance) is typically acceptable, and most sections shouldn’t require descriptive text if your options are self-explanatory. If you do want to change the location of your custom section, the priorities of the core sections are below:

Title | ID | Priority (Order)
----- | -- | ----------------
Site Title & Tagline | title_tagline | 20
Colors | colors | 40
Header Image | header_image | 60
Background Image | background_image | 80
Navigation | nav | 100
Widgets (Panel) | widgets | 110
Static Front Page | static_front_page | 120
default | - | 160

In most cases, sections can be added with only one or two parameters being specified. Here’s an example for adding a section for options that pertain to a theme’s footer:

```php
<?php
// Add a footer/copyright information section.
$wp_customize->add_section( 'footer' , array(
    'title' => __( 'Footer', 'themename' ),
    'priority' => 90, // Before Navigation.
) );
?>
```

##Panels

The Customizer Panels API was introduced in WordPress 4.0, and allows developers to create an additional layer of hierarchy beyond controls and sections. More than simply grouping sections of controls, panels are designed to provide distinct contexts for the Customizer, such as Customizing Widgets, Menus, browsing themes, or perhaps in the future, editing posts.

Generally speaking, it should not be necessary to create Panels for most themes’ options. Be sure to utilize Sections first, and remember that Sections should typically have several Controls in each. You should also add Controls to the Sections that core provides, such as putting color options in the colors Section. Also make sure that you’re keeping your options as streamlined and efficient as possible; the [WordPress philosophy](https://wordpress.org/about/philosophy/) page provides some good context here. If you do need to use Panels, you’ll find that the API is nearly identical to that for Sections:

```php
<?php
$wp_customize->add_panel( 'menus', array(
    'title' => __( 'Menus' ),
    'description' => $description, // Include html tags such as <p>.
    'priority' => 160, // Mixed with top-level-section hierarchy.
) );
$wp_customize->add_section( $section_id , array(
    'title' => $menu->name,
    'panel' => 'menus',
) );
?>
```

Panels must contain at least one Section, which must contain at least one Control, to be displayed. As you can see in the above example, Sections can be added to Panels similarly to how Controls are added to Sections. However, if the Panel parameter is empty when registering a Section, it will simply be displayed on the main, top-level Customizer context.

##Contextual Controls, Sections, and Panels

WordPress 4.0 and 4.1 also added support for making parts of the Customizer UI be visible or hidden depending on the part of the site that the user was previewing within the Customizer preview window. A simple contextual control example would be that your theme only displays the header image and the site tagline on the front page. This is a perfect use case for the Customizer Manager’s get_ methods, as we can modify the core controls for these settings directly to make them contextual to the front page:

```php
<?php
// Hide core sections/controls when they aren't used on the current page.
$wp_customize->get_section( 'header_image' )->active_callback = 'is_front_page';
$wp_customize->get_control( 'blogdescription' )->active_callback = 'is_front_page';
?>
```

![In this contextual control example, the theme only displays the site tagline on the front page, so the corresponding field in the Customizer is hidden when the user navigates to a different page within the preview window.](https://i1.wp.com/nick.halsey.co/wp-content/uploads/sites/2/2014/08/contextual-customize-controls.gif)

The `active_callback` parameter for Panels, Sections, and Controls takes a callback function name, either core or custom. This parameter can also be set when registering the object for objects that you add. Here’s an example from the Twenty Fourteen Theme:

```php
<?php
$wp_customize->add_section( 'featured_content', array(
    'title'       => __( 'Featured Content', 'twentyfourteen' ),
    'description' => //...
    'priority'        => 130,
    'active_callback' => 'is_front_page',
) );
?>
```

In the previous example, [is_front_page](https://developer.wordpress.org/reference/functions/is_front_page/) is used directly. But for more complex logic, such as checking if the current view is a page (or even a specific page, by id), custom functions can be used (see [#30251](https://core.trac.wordpress.org/ticket/30251) for details on why this is needed). If you don’t need to support PHP 5.2, this can be done inline:

```php
<?php 'active_callback' => function () { return is_page(); } ?>
```

PHP 5.2 support is as simple as creating a named function and referencing it with the `active_callback` parameter:

```php
<?php
//...
'active_callback' => 'prefix_return_is_page';
//...
function prefix_return_is_page() {
    return is_page();
}
?>
```

Within Custom Controls, Sections, and Panels, there is also an option to override the `active_callback` function directly within the custom Customizer object class:

```php
<?php
class WP_Customize_Greeting_Control extends WP_Customize_Control {
    // ...
    function active_callback() {
        return is_front_page();
    }
}
?>
```

Finally, there is a filter that can be used to override all other `active_callback` behavior:

```php
<?php
// Hide all controls without a description when previewing single posts.
function title_tagline_control_filter( $active, $control ) {
    if ( '' === $control->description ) {
        $active = is_singular();
    }
    return $active;
}
add_filter( 'customize_control_active', 'title_tagline_control_filter', 10, 2 );
?>
```

Note that the `active_callback` API works exactly the same for all of the Customizer object types (Controls, [Sections](https://developer.wordpress.org/reference/classes/wp_customize_section/active_callback/), and [Panels](https://developer.wordpress.org/reference/classes/wp_customize_panel/active_callback/)). As an added bonus, sections will automatically be hidden if all of the controls within them are contextually hidden, and the same works for panels.


##Using PostMessage For Improved Setting Previewing

The Customizer automatically handles previewing all settings out-of-the-box. This is done by silently reloading the entire preview window, with settings being filtered by PHP in that ajax call. While this works just fine, it can be very slow since the entire front-end must be reloaded for every single setting change. To provide a better user experience, the Customizer offers an API for managing setting changes directly in JavaScript, allowing for truly-live previewing. The below images show a comparison of a Custom CSS option that leverages this technology, called postMessage, against the standard refresh option:


![Custom CSS setting in the Customizer with the postMessage setting transport.](https://i1.wp.com/nick.halsey.co/wp-content/uploads/sites/2/2014/08/customize-setting-refresh-1.gif)


![Custom CSS setting in the Customizer with the default refresh setting transport.](https://i1.wp.com/nick.halsey.co/wp-content/uploads/sites/2/2014/08/customize-setting-postmessage.gif)

To use postMessage, first set the transport parameter to postMessage when adding your setting. Many themes also modify core settings such as the title and tagline to leverage postMessage by modifying the transport property of those settings:

```php
<?php
$wp_customize->get_setting( 'blogname' )->transport        = 'postMessage';
$wp_customize->get_setting( 'blogdescription' )->transport = 'postMessage';
?>
```

Once the setting’s transport is set to postMessage, the setting will no longer trigger a refresh of the preview when its value changes. To implement the JavaScript to update the setting within the preview of the front-end, first create and enqueue a JavaScript file:

```php
<?php
function my_preview_js() {
    wp_enqueue_script( 'custom_css_preview', 'path/to/file.js', array( 'customize-preview', 'jquery' ) );
}
add_action( 'customize_preview_init', 'my_preview_js' );
?>
```

Your JavaScript file should look something like this:

```js
( function( $ ) {
    wp.customize( 'setting_id', function( value ) {
        value.bind( function( to ) {
            $( '#custom-theme-css' ).html( to );
        } );
    } );
    wp.customize( 'custom_plugin_css', function( value ) {
        value.bind( function( to ) {
            $( '#custom-plugin-css' ).html( to );
        } );
    } );
} )( jQuery );
```

Note that you don’t necessarily need to be great with JavaScript to use postMessage – most of the code is boilerplate. The types of settings that benefit most from postMessage transport require simple JS changes such as using jQuery’s `.html()` or `.text()` methods, or swapping out a class on the `<body>` or another element to trigger a different set of CSS rules.

##Custom Controls, Sections, and Panels

Custom Controls, Sections, and Panels can be easily created by subclassing the PHP objects associated with each Customizer object: [WP_Customize_Control](https://developer.wordpress.org/reference/classes/wp_customize_control/), [WP_Customize_Section](https://developer.wordpress.org/reference/classes/wp_customize_section/), and [WP_Customize_Panel](https://developer.wordpress.org/reference/classes/wp_customize_panel/) (this can also be done for [WP_Customize_Setting](https://developer.wordpress.org/reference/classes/wp_customize_setting/), but custom settings are typically better implemented using custom setting types, as outlined in the next section). Here’s an example for a basic custom control:

```php
<?php
class WP_New_Menu_Customize_Control extends WP_Customize_Control {
    public $type = 'new_menu';
    /**
    * Render the control's content.
    */
    public function render_content() {
    ?>
        <button class="button button-primary" id="create-new-menu-submit" tabindex="0"><?php _e( 'Create Menu' ); ?></button>;
    <?php
    }
}
?>
```

By subclassing the base control class, you can override any functionality with custom functionality or use the core functionality depending on your needs. The most common function to override is `render_content()` as it allows you to create custom UI from scratch with HTML. Custom Controls should be used with caution, however, as they may introduce UI that is inconsistent with the surrounding core UI and cause confusion for users. Custom Customizer objects can be added similarly to how default controls, sections, and panels are added:

```php
<?php
$wp_customize->add_control(
    new WP_Customize_Color_Control(
        $wp_customize, // WP_Customize_Manager
        'accent_color', // Setting id
        array( // Args, including any custom ones.
            'label' => __( 'Accent Color' ),
            'section' =>; 'colors',
        )
    )
);
?>
```

Parameters passed when adding controls are mapped to class variables within the control class, so you can add and use custom ones where certain parts of your custom object are different across different instances.

When creating custom Controls, Sections, or Panels, it is strongly recommended to reference the core code, in order to fully understand the available functionality that can be overridden. Core also includes examples of custom objects of each type. This can be found in [wp-includes/class-wp-customize-control.php](https://core.trac.wordpress.org/browser/trunk/src/wp-includes/class-wp-customize-control.php), [wp-includes/class-wp-customize-section.php](https://core.trac.wordpress.org/browser/trunk/src/wp-includes/class-wp-customize-section.php), and [wp-includes/class-wp-customize-panel.php](https://core.trac.wordpress.org/browser/trunk/src/wp-includes/class-wp-customize-panel.php). There is also a JavaScript API for each Customizer object type, which can be extended with custom objects; see the Customizer JavaScript API section for more details.

##Custom Setting Types

By default, the Customizer supports saving settings as options or theme modifications. But this behavior can be easily overwritten to manually save and preview settings outside of the `wp_options` table of the WordPress database, or to apply other custom handling. To get started, specify a type other than option or theme_mod when adding your setting (you can use pretty much any string):

```php
<?php
$wp_customize->add_setting( $nav_menu_setting_id, array(
    'type' => 'nav_menu',
    'default' => $item_ids,
) );
?>
```

The setting will no longer be saved or previewed when its value is changed in the associated control. Now, you can use the `customize_update_$setting->type` and `customize_preview_$setting->type` actions to implement custom saving and previewing functionality. Here is an example for saving a menu item’s order property from the Menu Customizer project (the value of the setting is an ordered array of menu ids):

```php
<?php
function menu_customizer_update_nav_menu( $value, $setting ) {
    $menu_id = str_replace( 'nav_menu_', '', $setting->id );
    // ...
    $i = 0;
    foreach( $value as $item_id ) { // $value is ordered array of item ids.
        menu_customizer_update_menu_item_order( $menu_id, $item_id, $i );
    $i++;
    }
}
add_action( 'customize_update_nav_menu', 'menu_customizer_update_nav_menu', 10, 2 );
?>
```

And here is how the same plugin implements previewing for nav menu items (note that this example requires PHP 5.3 or higher):

```php
<?php
function menu_customizer_preview_nav_menu( $setting ) {
    $menu_id = str_replace( 'nav_menu_', '', $setting->id );
    add_filter( 'wp_get_nav_menu_items', function( $items, $menu, $args ) use ( $menu_id, $setting ) {
        $preview_menu_id = $menu->term_id;
        if ( $menu_id == $preview_menu_id ) {
            $new_ids = $setting->post_value();
            foreach ( $new_ids as $item_id ) {
                $item = wp_setup_nav_menu_item( $item );
                $item->menu_order = $i;
                $new_items[] = $item;
                $i++;
            }
            return $new_items;
        } else {
            return $items;
        }
    }, 10, 3 );
}
add_action( 'customize_preview_nav_menu', 'menu_customizer_preview_nav_menu', 10, 2 );
?>
```

##The Customizer JavaScript API

In WordPress 4.1, newly expanded JavaScript APIs were introduced for all Customizer objects. The entire JavaScript API is currently located in a single file, [wp-admin/js/customize-controls.js](https://core.trac.wordpress.org/browser/trunk/src/wp-admin/js/customize-controls.js), which contains models for all objects, core custom controls, and more.

###Models for Controls, Sections, and Panels

As in PHP, each Customizer object type has a corresponding object in JavaScript. There are `wp.customize.Control`, `wp.customize.Panel`, and `wp.customize.Section` models, as well as `wp.customize.panel`, `wp.customize.section`, and `wp.customize.control` collections (yes, they aresingular) that store all control instances. You can iterate over panels, sections, and controls via:

```js
wp.customize.panel.each( function ( panel ) { /* ... */ } );
wp.customize.section.each( function ( section ) { /* ... */ } );
wp.customize.control.each( function ( control ) { /* ... */ } );
```

###Relating Controls, Sections, and Panels together

When registering a new control in PHP, you pass in the parent section ID:

```php
<?php
$wp_customize->add_control( 'blogname', array(
    'label' => __( 'Site Title' ),
    'section' => 'title_tagline',
) );
?>
```

In the JavaScript API, a control’s section can be obtained predictably:

```js
id = wp.customize.control( 'blogname' ).section(); // => title_tagline
```

To get the section object from the ID, look up the section by the ID as normal: `wp.customize.section( id )`.

You can move a control to another section using this section state as well, here moving it to the Navigation section:

```js
wp.customize.control( 'blogname' ).section( 'nav' );
```

Likewise, you can get a section’s panel ID in the same way:

```js
id = wp.customize.section( 'sidebar-widgets-sidebar-1' ).panel(); // => widgets
```

You can go the other way as well, to get the children of panels and sections:

```js
sections = wp.customize.panel( 'widgets' ).sections();
controls = wp.customize.section( 'title_tagline' ).controls();
```

You can use these to move all controls from one section to another:

```js
_.each( wp.customize.section( 'title_tagline' ).controls(), function ( control ) {
    control.section( 'nav' );
});
```

###Contextual Panels, Sections, and Controls #

`Control`, `Panel`, and `Section` instances have an `active` state (a `wp.customize.Value` instance). When the `active` state changes, the panel, section, and control instances invoke their respective `onChangeActive` method, which by default slides the container element up and down, if `false` and `true` respectively. There are also `activate()` and `deactivate()` methods now for manipulating this `active` state, for panels, sections, and controls. The primary purpose of these states is to show or hide the object without removing it entirely from the Customizer.

```js
wp.customize.section( 'nav' ).deactivate(); // slide up
wp.customize.section( 'nav' ).activate({ duration: 1000 }); // slide down slowly
wp.customize.section( 'colors' ).deactivate({ duration: 0 }); // hide immediately
wp.customize.section( 'nav' ).deactivate({ completeCallback: function () {
    wp.customize.section( 'colors' ).activate(); // show after nav hides completely
} });
```

Note that manually changing the `active` state would only stick until the preview refreshes or loads another URL. The `activate()`/`deactivate()` methods are designed to follow the pattern of the new `expanded` state.

###Focusing

Building upon the `expand()`/`collapse()` methods for panels, sections, and controls, these models also support a `focus()` method which not only expands all of the necessary elements, but also scrolls the target container into view and puts the browser focus on the first focusable element in the container. For instance, to expand the “Static Front Page” section and focus on select dropdown for the “Front page”:

```js
wp.customize.control( 'page_on_front' ).focus()
```

The focus functionality is used to implement [autofocus](https://core.trac.wordpress.org/ticket/28650): deep-linking to panels, sections, and controls inside of the customizer. Consider these URLs:

- …/wp-admin/customize.php?autofocus[panel]=widgets
- …/wp-admin/customize.php?autofocus[section]=colors
- …/wp-admin/customize.php?autofocus[control]=blogname

This is used in WordPress core to [add a link](https://core.trac.wordpress.org/ticket/28032) on the widgets admin page to link directly to the widgets panel within the Customizer.

###Priorities

When registering a panel, section, or control in PHP, you can supply a `priority` parameter. This value is stored in a `wp.customize.Value` instance for each respective `Panel`, `Section`, and `Control` instance. For example, you can obtain the priority for the widgets panel via:

```js
priority = wp.customize.panel( 'widgets' ).priority(); // => 110
```

You can then dynamically change the priority and the Customizer UI will automatically re-arrange to reflect the new priorities:

```js
wp.customize.panel( 'widgets' ).priority( 1 ); // move Widgets to the top
```

###Custom Controls, Panels, and Sections

When working with custom Customizer objects in JS, it is usually easiest to examine the custom objects in WordPress core to understand the code structure. See [wp-admin/js/customize-controls.js](https://core.trac.wordpress.org/browser/trunk/src/wp-admin/js/customize-controls.js), particularly the `wp.customize.Panel|Section|Control` models.

##JavaScript/Underscore.js-Rendered Custom Controls

WordPress 4.1 also added support for rendering JavaScript-heavy and/or high-quantity controls entirely with JavaScript. This allows for more dynamic behavior, especially related to dynamically-added controls. The core Color and Media controls currently leverage this API, and all core Controls will eventually use it in the future. The PHP-based control API is not going away, but in the future most controls will likely use the new API since it is relatively easy to implement. Note that the APIs for dynamically-added controls, and APIs for JS-templated custom Sections and Panels are not yet available as of WordPress 4.2. See [#30741](https://core.trac.wordpress.org/ticket/30741).

###Registered Control Types

In order to introduce a concept of having one template for multiple Customizer controls of the same type, we needed to introduce a way to register a type of control with the Customize Manager. Previously, custom control objects were only encountered when custom controls were added using [WP_Customize_Manager::add_control()](https://developer.wordpress.org/reference/classes/wp_customize_manager/add_control/). But detecting added control types to render one template per type wouldn’t allow new controls to be created dynamically if no other instances of that type were loaded. So we’ve introduced [WP_Customize_Manager::register_control_type()](https://developer.wordpress.org/reference/classes/wp_customize_manager/register_control_type/). Usage is simple:

```php
<?php
add_action( 'customize_register', 'prefix_customize_register' );
function prefix_customize_register( $wp_customize ) {
    // Define a custom control class, WP_Customize_Custom_Control.
    // Register the class so that its JS template is available in the Customizer.
    $wp_customize->register_control_type( 'WP_Customize_Custom_Control' );
}
?>
```

All registered control types will have their templates printed to the Customizer by `WP_Customize_Manager::print_control_templates()`.

###Sending PHP Control Data to JavaScript

While Customizer control data has always been passed to the control JS models, and this has always been able to be extended, you’re much more likely to need to send data down when working with JS templates. Anything that you would want access to in `render_content()` in PHP will need to be exported to JavaScript to be accessible in your control template. `WP_Customize_Control` exports the following control class variables by default:

- type
- label
- description
- active (boolean state)

You can add additional parameters specific to your custom control by overriding [WP_Customize_Control::to_json()](https://developer.wordpress.org/reference/classes/wp_customize_control/to_json/) in your custom control subclass. In most cases, you’ll want to call the parent class’ `to_json()` method also, to ensure that all core variables are exported as well. Here’s an example from the core color control:

```php
<?php
public function to_json() {
    parent::to_json();
    $this->json['statuses'] = $this->statuses;
    $this->json['defaultValue'] = $this->setting->default;
}
?>
```

###JS/Underscore Templating

Once you’ve registered your custom control class as a control type and exported any custom class variables, you can create the template that will render the control UI. You’ll override [WP_Customize_Control::content_template()](https://developer.wordpress.org/reference/classes/wp_customize_control/content_template/) (empty by default) as a replacement for [WP_Customize_Control::render_content()](https://developer.wordpress.org/reference/classes/wp_customize_control/render_content/). Render content is still called, so be sure to override it with an empty function in your subclass as well.

Underscore-style custom control templates are very similar to PHP. As more and more of WordPress core becomes JavaScript-driven, these templates are becoming increasingly more common. Some sample template code in core can be found in [media](https://core.trac.wordpress.org/browser/trunk/src/wp-includes/media-template.php), [revisions](https://core.trac.wordpress.org/browser/trunk/src/wp-admin/includes/revision.php#L260), the [theme browser](https://core.trac.wordpress.org/browser/trunk/src/wp-admin/themes.php#L293), and even in the [Twenty Fifteen theme](https://core.trac.wordpress.org/browser/trunk/src/wp-content/themes/twentyfifteen/inc/customizer.php#L266), where a JS template is used to both save the color scheme data and instantly preview color scheme changes in the Customizer. The best way to learn how these templates work is to study similar code in core and, accordingly, here is a brief example:

```php
<?php
class WP_Customize_Color_Control extends WP_Customize_Control {
    public $type = 'color';
// ...
    /**
     * Render a JS template for the content of the color picker control.
     */
    public function content_template() {
        ?>
        <# var defaultValue = '';
        if ( data.defaultValue ) {
            if ( '#' !== data.defaultValue.substring( 0, 1 ) ) {
                defaultValue = '#' + data.defaultValue;
            } else {
                defaultValue = data.defaultValue;
            }
            defaultValue = ' data-default-color=' + defaultValue; // Quotes added automatically.
        } #>
        <label>
            <# if ( data.label ) { #>
                <span class="customize-control-title">{{{ data.label }}}</span>
            <# } #>
            <# if ( data.description ) { #>
                <span class="description customize-control-description">{{{ data.description }}}</span>
            <# } #>
            <div class="customize-control-content">
                <input class="color-picker-hex" type="text" maxlength="7" placeholder="<?php esc_attr_e( 'Hex Value' ); ?>" {{ defaultValue }} />
            </div>
        </label>
        <?php
    }
}
?>
```

In the above template for the core custom color control, you can see that after the closing PHP tag, we have a JS template. `<# #>` notation is used around statements to be evaluated – in most cases, this is used for conditionals. All of the control instance data that we exported to JS is stored in the `data` object, and we can print a variable using double (escaped) or triple (unescaped) brace notation `{{ }}`. As I said before, the best way to get the hang of writing controls like this is to read through existing examples. [WP_Customize_Upload_Control](https://core.trac.wordpress.org/browser/trunk/src/wp-includes/class-wp-customize-control.php#L639) was recently [updated to leverage this API](https://core.trac.wordpress.org/changeset/30309) as well, integrating nicely with the way the media manager is implemented, and squeezing a ton of functionality out of a minimal amount of code. If you want some really good practice, try converting some of the other core controls to use this API – and submit patches to core too, of course!

###Putting the pieces together

Here’s a summary of what’s needed to leverage the new API in a custom Customizer control subclass:

1. Make your `render_content()` function empty (but it does need to exist to override the default one).
2. Create a new function, `content_template()`, and put the old contents of `render_content()` there.
3. Add any custom class variables that are needed for the control to be exported to the JavaScript in the browser (the JSON data) by modifying the `to_json()` function (see [WP_Customize_Color_Control](https://developer.wordpress.org/reference/classes/wp_customize_color_control/) for an example).
4. Convert the PHP from `render_content()` into a JS template, using `<# #>` around JS statements to evaluate and `{{ }}` around variables to print. PHP class variables are available in the data object; for example, the label can be printed with `{{ data.label }}`.
5. **Register the custom control class/type.** This critical step tells the Customizer to print the template for this control. This is distinct from just printing templates for all controls that were added because the ideas are that many instances of this control type could be rendered from one template, and that any registered control types would be available for dynamic control-creation in the future. Just do something like `$wp_customize->register_control_type( 'WP_Customize_Color_Control' );`.

The PHP-only parts of the Customizer API are still fully supported and perfectly fine to use. But given our long term goals for making the Customizer more flexible for doing things like switching themes in the Customizer without a pageload, it is strongly encouraged to use JS/Underscore templates for all custom Customizer controls where feasible.

##Allow Non-administrators to Access the Customizer

Customizer access is controlled by the customize meta capability (mapped to edit_theme_options by default), which is assigned only to administrators by default. This allows for wider use of the Customizer’s extensive capability-access options, which are built into panels, sections, and settings. Additionally, this makes it possible to allow non-administrators to use the customizer for, for example, customizing posts. This change is an important step toward expanding the scope of the Customizer beyond themes.

```php
<?php
function allow_users_who_can_edit_posts_to_customize( $caps, $cap, $user_id ) {
    $required_cap = 'edit_posts';
    if ( 'customize' === $cap && user_can( $user_id, $required_cap ) ) {
        $caps = array( $required_cap );
    }
    return $caps;
}
add_filter( 'map_meta_cap', 'allow_users_who_can_edit_posts_to_customize', 10, 3 );
?>
```

Note that it is currently necessary to manually add links to the Customizer in the admin menu, admin bar, or elsewhere if you are granting the customize meta capability to non-administrator users.